/**
 * @fileoverview Inline worker code for bundler compatibility.
 *
 * ## Why This Exists
 *
 * Bundlers (webpack, vite, rspack, esbuild) don't include worker files by default.
 * This module provides inline worker code that works without external files.
 *
 * ## Security
 *
 * Uses `data:` URLs instead of `eval: true` - more secure and CSP-friendly.
 * The worker code is static (not from user input), so it's safe.
 *
 * @module bee-threads/inline-workers
 * @internal
 */
/**
 * Minimal inline worker code for normal function execution.
 * Self-contained - no external imports needed.
 */
export declare const INLINE_WORKER_CODE = "\n'use strict';\nconst { parentPort, workerData } = require('worker_threads');\nconst vm = require('vm');\n\nif (!parentPort) process.exit(1);\n\nconst port = parentPort;\nconst config = workerData || {};\nconst DEBUG_MODE = config.debugMode || false;\nconst LOW_MEMORY = config.lowMemoryMode || false;\nconst CACHE_SIZE = config.functionCacheSize || 100;\n\nconst MSG = { SUCCESS: 'success', ERROR: 'error', LOG: 'log' };\nconst LOG = { LOG: 'log', WARN: 'warn', ERROR: 'error', INFO: 'info', DEBUG: 'debug' };\n\nlet currentFn = null;\n\nconst cache = new Map();\nconst cacheOrder = [];\n\nfunction cacheGet(key) {\n  if (cache.has(key)) {\n    const idx = cacheOrder.indexOf(key);\n    if (idx > -1) { cacheOrder.splice(idx, 1); cacheOrder.push(key); }\n    return cache.get(key);\n  }\n  return null;\n}\n\nfunction cacheSet(key, value) {\n  if (cache.size >= CACHE_SIZE) {\n    const oldest = cacheOrder.shift();\n    if (oldest) cache.delete(oldest);\n  }\n  cache.set(key, value);\n  cacheOrder.push(key);\n}\n\nlet baseCtx = null;\nfunction getBaseContext() {\n  if (!baseCtx) {\n    baseCtx = vm.createContext({\n      console, setTimeout, setInterval, clearTimeout, clearInterval,\n      setImmediate, clearImmediate, queueMicrotask,\n      Buffer, process, URL, URLSearchParams, TextEncoder, TextDecoder,\n      AbortController, AbortSignal, Event, EventTarget,\n      atob, btoa, structuredClone,\n      Math, Date, JSON, Object, Array, String, Number, Boolean,\n      Map, Set, WeakMap, WeakSet, Promise, Symbol, BigInt,\n      Error, TypeError, RangeError, SyntaxError, ReferenceError,\n      AggregateError, EvalError, URIError,\n      parseInt, parseFloat, isNaN, isFinite, encodeURI, decodeURI,\n      encodeURIComponent, decodeURIComponent,\n      Uint8Array, Int8Array, Uint16Array, Int16Array,\n      Uint32Array, Int32Array, Float32Array, Float64Array,\n      BigInt64Array, BigUint64Array, ArrayBuffer, SharedArrayBuffer, DataView,\n      Proxy, Reflect, WeakRef, FinalizationRegistry,\n      require: require\n    });\n  }\n  return baseCtx;\n}\n\n// LRU cache for reconstructed context functions (avoids recompiling same fn in different contexts)\nconst ctxFnCache = new Map();\nconst CTX_FN_CACHE_SIZE = 64;\n\n// Reconstruct serialized functions from context using vm.Script (faster than eval!)\nfunction reconstructContext(context) {\n  if (!context) return context;\n  const result = {};\n  const keys = Object.keys(context);\n  for (let i = 0; i < keys.length; i++) {\n    const key = keys[i];\n    const value = context[key];\n    if (typeof value === 'string' && value.startsWith('__BEE_FN__:')) {\n      const fnStr = value.slice(11); // Remove '__BEE_FN__:' prefix\n      // Check cache first\n      let fn = ctxFnCache.get(fnStr);\n      if (!fn) {\n        try {\n          const script = new vm.Script('(' + fnStr + ')', { filename: 'bee-context-fn.js' });\n          fn = script.runInThisContext();\n          // LRU eviction\n          if (ctxFnCache.size >= CTX_FN_CACHE_SIZE) {\n            const firstKey = ctxFnCache.keys().next().value;\n            if (firstKey) ctxFnCache.delete(firstKey);\n          }\n          ctxFnCache.set(fnStr, fn);\n        } catch (e) {\n          throw new Error('Failed to reconstruct function \"' + key + '\": ' + e.message);\n        }\n      }\n      result[key] = fn;\n    } else {\n      result[key] = value;\n    }\n  }\n  return result;\n}\n\nfunction compile(src, context) {\n  // Reconstruct any serialized functions in context\n  const processedContext = reconstructContext(context);\n  \n  // IMPORTANT: Cache key must include context VALUES, not just keys!\n  const ctxKey = processedContext ? JSON.stringify(context) : '';\n  const key = src + '::' + ctxKey;\n  let fn = LOW_MEMORY ? null : cacheGet(key);\n  if (fn) return fn;\n\n  if (processedContext && Object.keys(processedContext).length > 0) {\n    // With context: use vm.Script (slower but needed for context injection)\n    const script = new vm.Script('(' + src + ')', { filename: 'bee-worker.js' });\n    const sandbox = Object.create(getBaseContext());\n    const keys = Object.keys(processedContext);\n    for (let i = 0; i < keys.length; i++) sandbox[keys[i]] = processedContext[keys[i]];\n    fn = script.runInContext(vm.createContext(sandbox));\n  } else {\n    // FAST PATH: No context - use new Function() which is 30x faster!\n    // vm.runInContext() has massive overhead even with cached context\n    fn = (new Function('return ' + src))();\n  }\n  \n  if (!LOW_MEMORY) cacheSet(key, fn);\n  return fn;\n}\n\nfunction serializeError(e) {\n  const s = { name: 'Error', message: '', stack: undefined };\n  if (DEBUG_MODE && currentFn) s._sourceCode = currentFn;\n  \n  if (e && typeof e === 'object' && 'name' in e && 'message' in e) {\n    s.name = String(e.name);\n    s.message = String(e.message);\n    s.stack = e.stack;\n    if (e.cause != null) s.cause = serializeError(e.cause);\n    if (Array.isArray(e.errors)) s.errors = e.errors.map(serializeError);\n    for (const k of Object.keys(e)) {\n      if (!['name','message','stack','cause','errors'].includes(k)) {\n        const v = e[k];\n        if (v === null || typeof v === 'string' || typeof v === 'number' || typeof v === 'boolean') s[k] = v;\n      }\n    }\n  } else if (e instanceof Error) {\n    s.name = e.name; s.message = e.message; s.stack = e.stack;\n  } else {\n    s.message = String(e);\n  }\n  return s;\n}\n\nprocess.on('uncaughtException', (err) => {\n  try { port.postMessage({ type: MSG.ERROR, error: serializeError(err) }); }\n  catch { process.exit(1); }\n});\n\nprocess.on('unhandledRejection', (reason) => {\n  try {\n    const err = reason instanceof Error ? reason : new Error(String(reason));\n    port.postMessage({ type: MSG.ERROR, error: serializeError(err) });\n  } catch { process.exit(1); }\n});\n\nconst stringify = (args) => args.map(String);\nconsole.log = (...a) => port.postMessage({ type: MSG.LOG, level: LOG.LOG, args: stringify(a) });\nconsole.warn = (...a) => port.postMessage({ type: MSG.LOG, level: LOG.WARN, args: stringify(a) });\nconsole.error = (...a) => port.postMessage({ type: MSG.LOG, level: LOG.ERROR, args: stringify(a) });\nconsole.info = (...a) => port.postMessage({ type: MSG.LOG, level: LOG.INFO, args: stringify(a) });\nconsole.debug = (...a) => port.postMessage({ type: MSG.LOG, level: LOG.DEBUG, args: stringify(a) });\n\nconst PATTERNS = [\n  /^function\\s*\\w*\\s*\\(/,\n  /^async\\s+function\\s*\\w*\\s*\\(/,\n  /^\\(.*\\)\\s*=>/,\n  /^\\w+\\s*=>/,\n  /^async\\s*\\(.*\\)\\s*=>/,\n  /^async\\s+\\w+\\s*=>/,\n  /^\\(\\s*\\[/,\n  /^\\(\\s*\\{/,\n];\n\nfunction validate(src) {\n  if (typeof src !== 'string') throw new TypeError('Function source must be a string');\n  const t = src.trim();\n  for (const p of PATTERNS) if (p.test(t)) return;\n  throw new TypeError('Invalid function source');\n}\n\nfunction apply(fn, args) {\n  if (!args || args.length === 0) return fn();\n  let result = fn(...args);\n  if (typeof result === 'function' && args.length > 1) {\n    result = fn;\n    for (const arg of args) {\n      if (typeof result !== 'function') break;\n      result = result(arg);\n    }\n  }\n  return result;\n}\n\n// ============================================================================\n// TURBO MODE HANDLER - V8 OPTIMIZED (uses structuredClone)\n// ============================================================================\n\nfunction handleTurbo(msg) {\n  const { type, fn: fnSrc, chunk, startIndex, endIndex, context, inputBuffer, outputBuffer, controlBuffer, initialValue, workerId } = msg;\n  \n  try {\n    const fn = compile(fnSrc, context);\n    if (typeof fn !== 'function') throw new TypeError('Turbo function failed to compile');\n    \n    // SharedArrayBuffer mode (for TypedArrays)\n    if (inputBuffer && outputBuffer) {\n      const inputView = new Float64Array(inputBuffer);\n      const outputView = new Float64Array(outputBuffer);\n      const start = startIndex || 0;\n      const end = endIndex || inputView.length;\n      \n      if (type === 'turbo_map') {\n        for (let i = start; i < end; i++) {\n          outputView[i] = fn(inputView[i], i);\n        }\n      }\n      \n      if (controlBuffer) {\n        const ctrl = new Int32Array(controlBuffer);\n        Atomics.add(ctrl, 0, 1);\n        Atomics.notify(ctrl, 0);\n      }\n      \n      port.postMessage({ type: 'turbo_complete', workerId, itemsProcessed: end - start });\n      return;\n    }\n    \n    // Regular chunk (structuredClone handles serialization)\n    if (!chunk) {\n      throw new Error('Turbo message missing chunk data');\n    }\n    \n    const chunkLen = chunk.length;\n    let result;\n    \n    if (type === 'turbo_map') {\n      result = new Array(chunkLen);\n      for (let i = 0; i < chunkLen; i++) result[i] = fn(chunk[i], i);\n    } else if (type === 'turbo_filter') {\n      result = [];\n      for (let i = 0; i < chunkLen; i++) if (fn(chunk[i], i)) result.push(chunk[i]);\n    } else if (type === 'turbo_reduce') {\n      let acc = initialValue;\n      for (let i = 0; i < chunkLen; i++) acc = fn(acc, chunk[i], i);\n      result = [acc];\n    } else {\n      throw new Error('Unknown turbo type: ' + type);\n    }\n    \n    port.postMessage({ type: 'turbo_complete', workerId, result, itemsProcessed: chunkLen });\n  } catch (e) {\n    port.postMessage({ type: 'turbo_error', workerId, error: serializeError(e), itemsProcessed: 0 });\n  }\n}\n\nport.on('message', (msg) => {\n  // Handle turbo messages\n  if (msg.type === 'turbo_map' || msg.type === 'turbo_filter' || msg.type === 'turbo_reduce') {\n    handleTurbo(msg);\n    return;\n  }\n  \n  const { fn: src, args, context } = msg;\n  currentFn = src;\n  \n  try {\n    validate(src);\n    const fn = compile(src, context);\n    if (typeof fn !== 'function') throw new TypeError('Not a function');\n    \n    const ret = apply(fn, args);\n    \n    if (ret && typeof ret === 'object' && typeof ret.then === 'function') {\n      ret.then(v => {\n        currentFn = null;\n        port.postMessage({ type: MSG.SUCCESS, value: v });\n      }).catch(e => {\n        port.postMessage({ type: MSG.ERROR, error: serializeError(e) });\n        currentFn = null;\n      });\n    } else {\n      currentFn = null;\n      port.postMessage({ type: MSG.SUCCESS, value: ret });\n    }\n  } catch (e) {\n    port.postMessage({ type: MSG.ERROR, error: serializeError(e) });\n    currentFn = null;\n  }\n});\n";
/**
 * Converts worker code to a data: URL (base64 encoded).
 * More secure than eval: true - works with CSP.
 */
export declare function createWorkerDataUrl(code: string): string;
//# sourceMappingURL=inline-workers.d.ts.map