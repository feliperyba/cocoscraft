/**
 * @fileoverview Browser Worker thread code for executing user functions.
 *
 * ## What This File Does
 *
 * This file exports a string containing the worker code that runs inside
 * each Web Worker. It:
 * 1. Receives function source + arguments + context from main thread
 * 2. Validates the function source (cached validation)
 * 3. Compiles using new Function() with LRU caching
 * 4. Executes the function (handles async and curried)
 * 5. Sends result back to main thread
 *
 * ## Why String Export?
 *
 * Browser Web Workers must be created from a URL (file or blob).
 * Since we want inline workers (no separate file), we create a Blob
 * from this code string and use URL.createObjectURL().
 *
 * @module bee-threads/worker
 */
/**
 * The worker code as a string.
 * This will be executed inside the Web Worker context.
 */
export declare const WORKER_CODE = "\n// ============================================================================\n// MESSAGE TYPES\n// ============================================================================\n\nconst MessageType = {\n  SUCCESS: 'success',\n  ERROR: 'error',\n  LOG: 'log'\n};\n\nconst LogLevel = {\n  LOG: 'log',\n  WARN: 'warn',\n  ERROR: 'error',\n  INFO: 'info',\n  DEBUG: 'debug'\n};\n\n// ============================================================================\n// WORKER CONFIG (from workerData equivalent)\n// ============================================================================\n\nlet workerConfig = {\n  functionCacheSize: 100,\n  lowMemoryMode: false,\n  debugMode: false\n};\n\n// Current function being executed (for debug)\nlet currentFnSource = null;\n\n// ============================================================================\n// FUNCTION CACHE (LRU)\n// ============================================================================\n\nconst fnCache = new Map();\nconst MAX_CACHE_SIZE = workerConfig.functionCacheSize;\n\n// Reconstructed function cache\nconst reconstructedFnCache = new Map();\nconst RECONSTRUCTED_FN_CACHE_SIZE = 64;\n\n// Function cache stats\nlet cacheHits = 0;\nlet cacheMisses = 0;\n\nfunction reconstructFunctions(context) {\n  const result = {};\n  const keys = Object.keys(context);\n  for (let i = 0, len = keys.length; i < len; i++) {\n    const key = keys[i];\n    const value = context[key];\n    if (typeof value === 'string' && value.startsWith('__BEE_FN__:')) {\n      const fnStr = value.slice(11);\n      let fn = reconstructedFnCache.get(fnStr);\n      if (!fn) {\n        try {\n          fn = new Function('return (' + fnStr + ')')();\n          if (reconstructedFnCache.size >= RECONSTRUCTED_FN_CACHE_SIZE) {\n            const firstKey = reconstructedFnCache.keys().next().value;\n            if (firstKey) reconstructedFnCache.delete(firstKey);\n          }\n          reconstructedFnCache.set(fnStr, fn);\n        } catch (e) {\n          throw new Error('Failed to reconstruct function \"' + key + '\": ' + e.message);\n        }\n      }\n      result[key] = fn;\n    } else {\n      result[key] = value;\n    }\n  }\n  return result;\n}\n\nfunction fastHash(str) {\n  let hash = 5381;\n  for (let i = 0, len = str.length; i < len; i++) {\n    hash = ((hash << 5) + hash) ^ str.charCodeAt(i);\n  }\n  return (hash >>> 0).toString(36);\n}\n\nfunction createContextKey(context, level) {\n  level = level || 0;\n  if (context === undefined) return '';\n  const ctxType = typeof context;\n  if (context === null || ctxType === 'string' || ctxType === 'number' || ctxType === 'boolean') {\n    return String(context);\n  }\n  if (context instanceof Date) {\n    return String(context.getTime());\n  }\n  if (ctxType === 'function') {\n    return fastHash(context.toString());\n  }\n  if (level >= 10) {\n    return fastHash(JSON.stringify(context));\n  }\n  level++;\n  if (Array.isArray(context)) {\n    let arrResult = '[';\n    let first = true;\n    for (let i = 0, len = context.length; i < len; i++) {\n      const itemKey = createContextKey(context[i], level);\n      if (itemKey) {\n        if (!first) arrResult += ',';\n        arrResult += itemKey;\n        first = false;\n      }\n    }\n    return arrResult + ']';\n  }\n  const keys = Object.keys(context);\n  const keysLen = keys.length;\n  if (!keysLen) return '';\n  if (keysLen > 1) keys.sort();\n  let objResult = '{';\n  let first = true;\n  for (let i = 0; i < keysLen; i++) {\n    const key = keys[i];\n    const value = createContextKey(context[key], level);\n    if (value) {\n      if (!first) objResult += '&';\n      objResult += key + ':' + value;\n      first = false;\n    }\n  }\n  return objResult + '}';\n}\n\nfunction getOrCompile(fnString, context) {\n  let hasContext = false;\n  if (context) {\n    for (const _ in context) { hasContext = true; break; }\n  }\n\n  const contextKey = hasContext ? createContextKey(context) : '';\n  const cacheKey = contextKey ? fnString + '::' + contextKey : fnString;\n\n  let fn = fnCache.get(cacheKey);\n  if (fn) {\n    cacheHits++;\n    // LRU: move to end\n    fnCache.delete(cacheKey);\n    fnCache.set(cacheKey, fn);\n    return fn;\n  }\n\n  cacheMisses++;\n\n  if (!hasContext) {\n    fn = new Function('return ' + fnString)();\n  } else {\n    const processedContext = reconstructFunctions(context);\n    const contextKeys = Object.keys(processedContext);\n    const contextValues = contextKeys.map(function(k) { return processedContext[k]; });\n    const wrapperFn = new Function(...contextKeys, 'return (' + fnString + ')');\n    fn = wrapperFn(...contextValues);\n  }\n\n  fnCache.set(cacheKey, fn);\n\n  // LRU eviction\n  if (fnCache.size > MAX_CACHE_SIZE) {\n    const oldestKey = fnCache.keys().next().value;\n    if (oldestKey !== undefined) {\n      fnCache.delete(oldestKey);\n    }\n  }\n\n  return fn;\n}\n\n// ============================================================================\n// CONSOLE REDIRECTION\n// ============================================================================\n\nfunction argsToStrings(args) {\n  const len = args.length;\n  const result = new Array(len);\n  for (let i = 0; i < len; i++) {\n    result[i] = String(args[i]);\n  }\n  return result;\n}\n\nconst originalConsole = {\n  log: console.log,\n  warn: console.warn,\n  error: console.error,\n  info: console.info,\n  debug: console.debug\n};\n\nconsole.log = function() {\n  const args = Array.prototype.slice.call(arguments);\n  self.postMessage({ type: MessageType.LOG, level: LogLevel.LOG, args: argsToStrings(args) });\n};\n\nconsole.warn = function() {\n  const args = Array.prototype.slice.call(arguments);\n  self.postMessage({ type: MessageType.LOG, level: LogLevel.WARN, args: argsToStrings(args) });\n};\n\nconsole.error = function() {\n  const args = Array.prototype.slice.call(arguments);\n  self.postMessage({ type: MessageType.LOG, level: LogLevel.ERROR, args: argsToStrings(args) });\n};\n\nconsole.info = function() {\n  const args = Array.prototype.slice.call(arguments);\n  self.postMessage({ type: MessageType.LOG, level: LogLevel.INFO, args: argsToStrings(args) });\n};\n\nconsole.debug = function() {\n  const args = Array.prototype.slice.call(arguments);\n  self.postMessage({ type: MessageType.LOG, level: LogLevel.DEBUG, args: argsToStrings(args) });\n};\n\n// ============================================================================\n// ERROR SERIALIZATION\n// ============================================================================\n\nfunction serializeError(e) {\n  const serialized = {\n    name: 'Error',\n    message: '',\n    stack: undefined,\n    _sourceCode: (workerConfig.debugMode && currentFnSource) ? currentFnSource : undefined,\n    cause: undefined,\n    errors: undefined\n  };\n\n  if (e && typeof e === 'object' && 'name' in e && 'message' in e) {\n    serialized.name = String(e.name);\n    serialized.message = String(e.message);\n    serialized.stack = e.stack;\n    \n    if ('cause' in e && e.cause != null) {\n      serialized.cause = serializeError(e.cause);\n    }\n    \n    if ('errors' in e && Array.isArray(e.errors)) {\n      const errArray = e.errors;\n      const len = errArray.length;\n      const serializedErrors = new Array(len);\n      for (let j = 0; j < len; j++) {\n        serializedErrors[j] = serializeError(errArray[j]);\n      }\n      serialized.errors = serializedErrors;\n    }\n    \n    const errObjKeys = Object.keys(e);\n    for (let i = 0, len = errObjKeys.length; i < len; i++) {\n      const key = errObjKeys[i];\n      if (key !== 'name' && key !== 'message' && key !== 'stack' && key !== 'cause' && key !== 'errors') {\n        const value = e[key];\n        if (value === null || typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean') {\n          serialized[key] = value;\n        }\n      }\n    }\n  } else if (e instanceof Error) {\n    serialized.name = e.name;\n    serialized.message = e.message;\n    serialized.stack = e.stack;\n    if (e.cause != null) {\n      serialized.cause = serializeError(e.cause);\n    }\n  } else {\n    serialized.message = String(e);\n  }\n  \n  return serialized;\n}\n\n// ============================================================================\n// FUNCTION VALIDATION\n// ============================================================================\n\nconst VALID_FUNCTION_PATTERNS = [\n  /^function\\s*\\w*\\s*\\(/,\n  /^async\\s+function\\s*\\w*\\s*\\(/,\n  /^\\(.*\\)\\s*=>/,\n  /^\\w+\\s*=>/,\n  /^async\\s*\\(.*\\)\\s*=>/,\n  /^async\\s+\\w+\\s*=>/,\n  /^\\(\\s*\\[/,\n  /^\\(\\s*\\{/\n];\nconst PATTERNS_LEN = VALID_FUNCTION_PATTERNS.length;\n\nconst validatedSources = new Set();\nconst MAX_VALIDATION_CACHE = 200;\n\nfunction validateFunctionSource(src) {\n  if (typeof src !== 'string') {\n    throw new TypeError('Function source must be a string');\n  }\n\n  if (!workerConfig.lowMemoryMode && validatedSources.has(src)) {\n    return;\n  }\n\n  const firstChar = src.charCodeAt(0);\n  const trimmed = (firstChar === 32 || firstChar === 9 || firstChar === 10 || firstChar === 13)\n    ? src.trim()\n    : src;\n\n  let isValid = false;\n  for (let i = 0; i < PATTERNS_LEN; i++) {\n    if (VALID_FUNCTION_PATTERNS[i].test(trimmed)) {\n      isValid = true;\n      break;\n    }\n  }\n  if (!isValid) {\n    throw new TypeError('Invalid function source');\n  }\n\n  if (!workerConfig.lowMemoryMode) {\n    if (validatedSources.size >= MAX_VALIDATION_CACHE) {\n      validatedSources.clear();\n    }\n    validatedSources.add(src);\n  }\n}\n\n// ============================================================================\n// CURRIED FUNCTION SUPPORT\n// ============================================================================\n\nfunction applyCurried(fn, args) {\n  const argsLen = args ? args.length : 0;\n  if (argsLen === 0) {\n    return fn();\n  }\n\n  let result = fn.apply(null, args);\n\n  if (typeof result === 'function' && argsLen > 1) {\n    result = fn;\n    for (let i = 0; i < argsLen; i++) {\n      if (typeof result !== 'function') break;\n      result = result(args[i]);\n    }\n  }\n\n  return result;\n}\n\n// ============================================================================\n// TURBO MODE HANDLER\n// ============================================================================\n\nfunction isTurboMessage(msg) {\n  return msg !== null && typeof msg === 'object' && 'type' in msg &&\n    (msg.type === 'turbo_map' || msg.type === 'turbo_filter' || msg.type === 'turbo_reduce');\n}\n\nfunction handleTurboMessage(message) {\n  const type = message.type;\n  const fnSrc = message.fn;\n  const chunk = message.chunk;\n  const startIndex = message.startIndex;\n  const endIndex = message.endIndex;\n  const context = message.context;\n  const inputBuffer = message.inputBuffer;\n  const outputBuffer = message.outputBuffer;\n  const turboControl = message.controlBuffer;\n  const initialValue = message.initialValue;\n\n  try {\n    const fn = getOrCompile(fnSrc, context);\n\n    if (typeof fn !== 'function') {\n      throw new TypeError('Turbo function did not compile correctly');\n    }\n\n    // SharedArrayBuffer mode (for TypedArrays)\n    if (inputBuffer && outputBuffer) {\n      const inputView = new Float64Array(inputBuffer);\n      const outputView = new Float64Array(outputBuffer);\n      const start = startIndex !== undefined ? startIndex : 0;\n      const end = endIndex !== undefined ? endIndex : inputView.length;\n\n      if (type === 'turbo_map') {\n        for (let i = start; i < end; i++) {\n          outputView[i] = fn(inputView[i], i);\n        }\n      }\n\n      if (turboControl) {\n        const cv = new Int32Array(turboControl);\n        Atomics.add(cv, 0, 1);\n        Atomics.notify(cv, 0);\n      }\n\n      self.postMessage({\n        type: 'turbo_complete',\n        workerId: message.workerId,\n        itemsProcessed: end - start\n      });\n      return;\n    }\n\n    // Regular chunk\n    if (!chunk) {\n      throw new Error('Turbo message missing chunk data');\n    }\n    \n    const chunkLen = chunk.length;\n    let result;\n\n    if (type === 'turbo_map') {\n      result = new Array(chunkLen);\n      for (let i = 0; i < chunkLen; i++) {\n        result[i] = fn(chunk[i], i);\n      }\n    } else if (type === 'turbo_filter') {\n      result = [];\n      for (let i = 0; i < chunkLen; i++) {\n        if (fn(chunk[i], i)) {\n          result.push(chunk[i]);\n        }\n      }\n    } else if (type === 'turbo_reduce') {\n      let acc = initialValue;\n      for (let i = 0; i < chunkLen; i++) {\n        acc = fn(acc, chunk[i], i);\n      }\n      result = [acc];\n    } else {\n      throw new Error('Unknown turbo type: ' + type);\n    }\n\n    self.postMessage({\n      type: 'turbo_complete',\n      workerId: message.workerId,\n      result: result,\n      itemsProcessed: chunkLen\n    });\n    return;\n\n  } catch (e) {\n    self.postMessage({\n      type: 'turbo_error',\n      workerId: message.workerId,\n      error: serializeError(e),\n      itemsProcessed: 0\n    });\n  }\n}\n\n// ============================================================================\n// MESSAGE PROCESSING\n// ============================================================================\n\nfunction processMessage(message) {\n  // Handle config message\n  if (message && message.type === 'config') {\n    if (message.functionCacheSize !== undefined) {\n      workerConfig.functionCacheSize = message.functionCacheSize;\n    }\n    if (message.lowMemoryMode !== undefined) {\n      workerConfig.lowMemoryMode = message.lowMemoryMode;\n    }\n    if (message.debugMode !== undefined) {\n      workerConfig.debugMode = message.debugMode;\n    }\n    return;\n  }\n\n  // Handle turbo messages\n  if (isTurboMessage(message)) {\n    handleTurboMessage(message);\n    return;\n  }\n\n  const src = message.fn;\n  const args = message.args;\n  const context = message.context;\n  \n  currentFnSource = src;\n  \n  try {\n    validateFunctionSource(src);\n    const fn = getOrCompile(src, context);\n\n    if (typeof fn !== 'function') {\n      throw new TypeError('Evaluated source did not produce a function');\n    }\n\n    const ret = applyCurried(fn, args);\n\n    if (ret && typeof ret === 'object' && 'then' in ret && typeof ret.then === 'function') {\n      ret\n        .then(function(v) {\n          self.postMessage({ type: MessageType.SUCCESS, value: v });\n        })\n        .catch(function(e) {\n          self.postMessage({ type: MessageType.ERROR, error: serializeError(e) });\n        })\n        .finally(function() {\n          currentFnSource = null;\n        });\n    } else {\n      self.postMessage({ type: MessageType.SUCCESS, value: ret });\n      currentFnSource = null;\n    }\n  } catch (e) {\n    self.postMessage({ type: MessageType.ERROR, error: serializeError(e) });\n    currentFnSource = null;\n  }\n}\n\n// ============================================================================\n// MESSAGE LOOP\n// ============================================================================\n\nself.onmessage = function(e) {\n  processMessage(e.data);\n};\n\n// Global error handler\nself.onerror = function(e) {\n  self.postMessage({\n    type: MessageType.ERROR,\n    error: serializeError(e)\n  });\n};\n";
/**
 * Creates a Blob URL for the worker code.
 * @returns URL that can be used to create a Web Worker
 */
export declare function createWorkerBlobUrl(): string;
/**
 * Gets or creates the worker blob URL.
 * @returns Cached blob URL for worker creation
 */
export declare function getWorkerBlobUrl(): string;
//# sourceMappingURL=worker.d.ts.map